
#include "Game.h"

// Call order:
//      Game constructor
//          Init
//          ReadLevel
//              ReadHeader
//              ReadLayerData
//              ReadEntityData
//                  PlaceEntity
//      While loop in main
//      UpdateAndRender:
//          Update
//          Render
//              RenderLevel
//      Game destructor

Game::Game() {

    Init();
    
    done = false;
    lastFrameTicks = 0.0f;
    timeLeftOver = 0.0f;
    
    mainSpriteTexture = LoadTexture("laurasfirstsprite.png");
    
    // Get level sprite array from txt file generated by Tiles
    
    ReadLevel();
    
}

Game::~Game() {
    SDL_Quit();

}

void Game::Init() {
    
    SDL_Init(SDL_INIT_VIDEO);
    
    displayWindow = SDL_CreateWindow("laupsygame",
                                     SDL_WINDOWPOS_CENTERED,
                                     SDL_WINDOWPOS_CENTERED,
                                     800, 600,
                                     SDL_WINDOW_OPENGL);
    
    SDL_GLContext context = SDL_GL_CreateContext(displayWindow);
    SDL_GL_MakeCurrent(displayWindow, context);
    
    glViewport(0,0,800,600);
    glMatrixMode(GL_PROJECTION);
    glOrtho(-1.33, 1.33, -1.0, 1.0, -1.0, 1.0);
    glClear(GL_COLOR_BUFFER_BIT);
    
}

void Game::Update(float elapsed) {
    
    // Spawn animated objects to collect
    // Update entities eg blocks and decor
    for ( size_t i = 0; i < entities.size(); i++ ) entities[i]->Update(elapsed);
    // Update any timers
    
}

void Game::FixedUpdate() {
    
    // Call FixedUpdate per entity
    // Check and update information about entities states (eg colliding jumping static visible)
    // Updating physics must also update by fixed timestep (eg something = something * FIXED_TIMESTEP)
    
}

void Game::Render() {
    
    // Call glClear
    glClear(GL_COLOR_BUFFER_BIT);
    // Render each entity
    for ( size_t i = 0; i < entities.size(); i++ ) entities[i]->Draw();
    // Call RenderLevel.  This will render the level aka build the world
    RenderLevel();
    
    SDL_GL_SwapWindow(displayWindow);
    
}

bool Game::UpdateAndRender() {
    
    // Must have fixed timestep:
    // A fixed timestep is necessary for a consistent gameplay speed
    // This makes movement consistent - eg if you want something to move x pixels per tick,
    // a fixed timestep will prevent better video cards from moving something x pixels per half that tick
    // or worse video cards fro moving something x pixels per double that tick
    
    float ticks = (float)SDL_GetTicks()/1000.0f;
    float elapsed = ticks - lastFrameTicks;
    lastFrameTicks = ticks;
    
    float fixedElapsed = elapsed + timeLeftOver;
    
    if ( fixedElapsed > FIXED_TIMESTEP * MAX_TIMESTEPS ) fixedElapsed = FIXED_TIMESTEP * MAX_TIMESTEPS;
    
    // Update and render
    Update(elapsed);
    Render();
    
    // This bool determines whether or not the loop in main ends
    return done;
    
}

void Game::RenderLevel() {
    
    // "glBindTexture â€” bind a named texture to a texturing target"
    // "glBindTexture lets you create or use a named texture. Calling glBindTexture with target set to GL_TEXTURE_2D or GL_TEXTURE_CUBE_MAP and texture set to the name of the new texture binds the texture name to the target of the current active texture unit. When a texture is bound to a target, the previous binding for that target is automatically broken."
    
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, mainSpriteTexture);
    
    vector<float> vertexData;
    vector<float> texCoordData;
    
    //    cout << mapWidth << endl;
    
  //  levelData[0][0] = '3';
    
  //  cout << "Level data: " << *levelData[0] << endl;
    
    for ( size_t y = 0; y < 1; y++ ) {
        for ( size_t x = 0; x < 1; x++ ) {
            
            if ( levelData[y][x] != 0 ) { // why bad access code..
                float u = (float)(((int)levelData[y][x]) % SPRITE_COUNT_X) / (float)SPRITE_COUNT_X;
                float v = (float)(((int)levelData[y][x]) / SPRITE_COUNT_X) / (float)SPRITE_COUNT_Y;
                float spriteWidth = 1.0f / (float)SPRITE_COUNT_X;
                float spriteHeight = 1.0f / (float)SPRITE_COUNT_Y;
                
                vertexData.insert(vertexData.end(), {
                    TILE_SIZE * x, -TILE_SIZE * y,
                    TILE_SIZE * x, (-TILE_SIZE * y)-TILE_SIZE,
                    (TILE_SIZE * x)+TILE_SIZE, (-TILE_SIZE * y)-TILE_SIZE,
                    (TILE_SIZE * x)+TILE_SIZE, -TILE_SIZE * y
                });
                texCoordData.insert(texCoordData.end(), { u, v,
                    u, v+(spriteHeight),
                    u+spriteWidth, v+(spriteHeight),
                    u+spriteWidth, v
                });
            }
        }
    }
    
    glVertexPointer(2, GL_FLOAT, 0, vertexData.data());
    glEnableClientState(GL_VERTEX_ARRAY);
    glTexCoordPointer(2, GL_FLOAT, 0, texCoordData.data());
    glEnableClientState(GL_TEXTURE_COORD_ARRAY);

    // Center the window
    
    glLoadIdentity();
    glTranslatef(-TILE_SIZE * LEVEL_WIDTH/2, TILE_SIZE * LEVEL_HEIGHT/2, 0.0f);

}

void Game::RenderStart() {
    
    SDL_Event event;
    
    //    while (SDL_PollEvent(&event)) {
    //        if (event.type == SDL_QUIT || event.type == SDL_WINDOWEVENT_CLOSE) done = true;
    //        else if (event.key.keysym.scancode == SDL_SCANCODE_RETURN && !event.key.repeat) state = STATE_GAME_LEVEL;
    //    }
    
}

void Game::RenderGameOver() {
    
    SDL_Event event;
    
    //    while (SDL_PollEvent(&event)) {
    //        if (event.type == SDL_QUIT || event.type == SDL_WINDOWEVENT_CLOSE) done = true;
    //        else if (event.key.keysym.scancode == SDL_SCANCODE_S && !event.key.repeat) state = STATE_START;
    //    }
    
}

bool Game::readHeader(std::ifstream &stream) {
    
    // ONLY APPLIES TO txt data within the header portion of the file
    
    string line;
    
    mapWidth = -1;
    mapHeight = -1;
    
    while ( getline(stream, line) ) {
        
        // If it's empty or reached the end
        if ( line == "" ) { break; }
        // sStream is a stringstream: "stream class to operate on strings"
        istringstream sStream(line);
        string key, value;
        // " getline(a,b,c): Get line from stream into string:  Extracts characters from 'is' and stores them into 'str' until the delimitation character delim is found (or the newline character, '\n', for (2))."
        getline(sStream, key, '='); // = is the delim
        getline(sStream, value);
        
        if ( key == "width" ) {
            // atoi converts string to integer and c_str gets the string equiv of a bunch of chars (?)
            mapWidth = atoi(value.c_str());
            // setting mapWidth to the count of numbers in a line
        }
        else if ( key == "height" ) {
            mapHeight = atoi(value.c_str());
            // same w height
        }
    }
    
    // This gets called if the while loop doesn't run - if the file is empty
    if ( mapWidth == -1 || mapHeight == -1 ) return false;
    
    // Otherwise the data parsed from the file is filled into levelData
    else {
        levelData = new unsigned char*[mapHeight];
        for ( size_t i = 0; i < mapHeight; ++i ) {
            levelData[i] = new unsigned char[mapWidth];
        }
        return true;
    }
    
    // Return value specifies whether or not the file had parseable header data
    
}

bool Game::readLayerData(std::ifstream &stream) {
    
    string line;
    
    while ( getline(stream, line) ) {
        
        if ( line == "" ) { break; }
        
        istringstream sStream(line);
        string key, value;
        getline(sStream, key, '=');
        getline(sStream, value);
        
        if ( key == "data" ) {
            
            for ( size_t y = 0; y < mapHeight; y++ ) {
                
                // access code violation here now
                
                cout << "Y is : " << y << " and mapHeight is : " << mapHeight << endl;
                getline(stream, line);
                istringstream lineStream(line);
                string tile;
                
                // this loops through levelData.. so that means it already expects leveldata to have information?
                
                // fills levelData with spritesheet index of each tile
                
                for ( size_t x = 0; x < mapWidth; x++ ) {
                    
                    cout << "X is : " << x << " and mapWidth is : " << mapWidth << endl;
                    
                    getline(lineStream, tile, ',');
                    unsigned char val = (unsigned char)atoi(tile.c_str());
                    
                    cout << "val is : " << &val << endl;
                    
                    // this fixes the index (bc it is 1 extra in the txt file)
                    if ( val > 0 ) levelData[y][x] = val - 1;
                    else levelData[y][x] = 0;
                    
                }
            }
        }
    }
    
    return true;
}

bool Game::readEntityData(std::ifstream &stream) {
    
    string line;
    string type;
    
    while ( getline(stream, line) ) {
        
        if ( line == "" ) { break; }
        istringstream sStream(line);
        string key, value;
        
        getline(sStream, key, '=');
        getline(sStream, value);
        
        if ( key == "type" ) type = value;
        
        else if ( key == "location" ) {
            
            istringstream lineStream(value);
            string xPosition, yPosition;
            
            getline(lineStream, xPosition, ',');
            getline(lineStream, yPosition, ',');
            
            float placeX = atoi(xPosition.c_str())/16*TILE_SIZE;
            float placeY = atoi(yPosition.c_str())/16*-TILE_SIZE;
            
            placeEntity(placeX, placeY);
            
        }
        
    }
    
    return true;
    
}

void Game::ReadLevel() {
    
    // Load the file
    ifstream infile("Maps/map.txt");
    string line;
    // Loop through file
    
    
    // check if exists bc returning false RN
    
//    if (infile) cout << "exists" << endl;
    
    while ( getline(infile, line) ) { // why is this false..
        cout << "This is a line" << line << endl;
        // Identify header
        if ( line == "[header]" ) {
            cout << "reading header" << endl;
            if ( !readHeader(infile) ) {
                // if the header portion is empty then stop trying to fill the array bc that means the entire file is empty
                return;
            }
        }

        else if ( line == "[layer]" ) {
            cout << "reading layer" << endl;
            // fills levelData
            readLayerData(infile);
        }
        
        else if ( line == "[ObjectsLayer]" ) {
            cout << "reading obj" << endl;
            // calls PlaceEntity based on results, which contain type and location
            readEntityData(infile);
        }
        
    }
    
}

void Game::placeEntity(float placeX, float placeY) {

        // Create entity
        // Add entity to vector
    
        SheetSprite mainSprite = SheetSprite(mainSpriteTexture, 12, 8, 15);
        Entity * e = new Entity(mainSprite,0.2f,0.2f,placeX,placeY);
        entities.push_back(e);

}

// Linear Interpolation
// This combines movement
// Example:
// velocity_x = lerp(velocity_x, 0.0f, FIXED_TIMESTEP * friction_x);
// velocity_y = lerp(velocity_y, 0.0f, FIXED_TIMESTEP * friction_y);
// velocity_x += acceleration_x * FIXED_TIMESTEP;
// velocity_y += acceleration_y * FIXED_TIMESTEP;
// x += velocity_x * FIXED_TIMESTEP;
// y += velocity_y * FIXED_TIMESTEP;

float Game::lerp(float v0, float v1, float t) {
    return (1.0 - t) * v0 + t * v1;
}

GLuint Game::LoadTexture(const char *image_path) {
    
    SDL_Surface *surface = IMG_Load(image_path);
    GLuint textureID;
    glGenTextures(1, &textureID);
    glBindTexture(GL_TEXTURE_2D, textureID);
    glTexImage2D(GL_TEXTURE_2D, 0, 4, surface->w, surface->h, 0, GL_BGRA, GL_UNSIGNED_BYTE, surface->pixels);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    SDL_FreeSurface(surface);
    return textureID;
    
}
void Game::DrawText( GLuint textTexture, string text, float x, float y, float spacing, float size, float r, float g, float b, float a ) {
    
    glBindTexture(GL_TEXTURE_2D, textTexture);
    glEnable(GL_TEXTURE_2D);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glLoadIdentity();
    glTranslatef( x, y, 0.0 );
    vector<float> vertexData;
    vector<float> textCoordData;
    vector<float> colorData;
    float textureSize = 1.0/16.0f;
    for ( int i=0; i <text.size(); i++ ) {
        float textX = (float) (((int)text[i]) % 16 ) / 16.0f;
        float textY = (float) (((int)text[i]) / 16 ) / 16.0f;
        vertexData.insert(vertexData.end(), {
            ((size+spacing) * i) + (-0.5f * size), 0.5f * size,
            ((size+spacing) * i) + (-0.5f * size), -0.5f * size,
            ((size+spacing) * i) + (0.5f * size), -0.5f * size,
            ((size+spacing) * i) + (0.5f * size), 0.5f * size});
        colorData.insert(colorData.end(), {r,g,b,a, r,g,b,a, r,g,b,a, r,g,b,a});
        textCoordData.insert(textCoordData.end(),
                             {   textX,
                                 textY,
                                 textX,
                                 textY + textureSize,
                                 textX + textureSize,
                                 textY + textureSize,
                                 textX + textureSize,
                                 textY
                             });
    }
    glColorPointer(4, GL_FLOAT, 0, colorData.data());
    glEnableClientState(GL_COLOR_ARRAY);
    glVertexPointer (2, GL_FLOAT, 0, vertexData.data());
    glEnableClientState(GL_VERTEX_ARRAY);
    glTexCoordPointer(2, GL_FLOAT, 0, textCoordData.data());
    glEnableClientState( GL_TEXTURE_COORD_ARRAY);
    glDrawArrays(GL_QUADS, 0, text.size() * 4.0);
    glDisableClientState(GL_COLOR_ARRAY);
    glDisableClientState(GL_VERTEX_ARRAY);
    glDisableClientState(GL_TEXTURE_COORD_ARRAY);
    
}









